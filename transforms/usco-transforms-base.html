<script src="TransformControls.js"></script>
<script src="operations.js"></script>


<polymer-element name="usco-transforms-base" attributes="selectedObject activeTool enabled">
  <script>
    Polymer("usco-transforms-base",{
      controls : null,
      activeTool:null,
      _prevTool:null,
      _tools: ["translate","rotate","scale","mirror","align"],
      _controlableTools : ["translate","rotate","scale"],
    
      observe:{
        'selectedObject.position.x':'objectPosChanged',
        'selectedObject.position.y':'objectPosChanged',
        'selectedObject.position.z':'objectPosChanged',
        
        'selectedObject.rotation.x':'objectRotChanged',
        'selectedObject.rotation.y':'objectRotChanged',
        'selectedObject.rotation.z':'objectRotChanged',
        
        'selectedObject.scale.x'   :'objectScaleChanged',
        'selectedObject.scale.y'   :'objectScaleChanged',
        'selectedObject.scale.z'   :'objectScaleChanged'
      },  
      //methodsToInject: ["thingamagig"],
      attached:function(){
        this.super();
        
        this._origPos = null;
        //this.objectPosChanged = 
      },
      //internal helpers
      init:function( camera, domElement ){
        //camera & dom element needed
        this.controls = new THREE.TransformControls( camera, domElement );
        //this.addToScene( this.controls, "helpers", {autoResize:false, autoCenter:false, persistent:true, select:false } );
        this.controls.enabled = false;
      },
      //attribute change callbacks
      _mainAttrChangedHelper:function( oldVal, newVal, data ){
      
      
      },
      
      objectPosChanged:function( oldPos, newPos, data ){
        //console.log("oldPos", oldPos, newPos,"idx",idx,data);
        //TODO: multiple axes changes ??
        
        if(!this.selectedObject) return;
        //FIXME: horrible hack!: this is done to prevent retriggering events when the undo 
        //redo operations change an object
        if(this.selectedObject._undoRedoFlag === true){
          this.selectedObject._undoRedoFlag = false;
          return;
        }
        if(! this._origPos){
          var idx = data[1] . length-1 ;
          var arr = [ data[0][0], data[0][1], data[0][2] ] ;
          arr[ idx ] = oldPos;
          var pos = new THREE.Vector3(arr).fromArray( arr );
          //console.log("gna",oldPos, newPos, pos);
          this._origPos = pos;
        }
        this.job("objectPosChanged", function(){
          var pos = new THREE.Vector3().fromArray( [ data[0][0], data[0][1], data[0][2] ] );
          //console.log("oldPos, newPos",this._origPos, pos);
          var offset = pos.clone().sub( this._origPos );
          //console.log("offset",offset);
          if(offset.length() > 0 )
          {
            var operation = new Translation( offset , this.selectedObject );
            var event = new CustomEvent('newOperation',{detail: {msg: operation}});
          
            this.dispatchEvent(event);
          }
          this._origPos = null;
          
        }, 100)
      },
      
      objectRotChanged:function( oldRot, newRot, data ){
        console.log("oldRot, newRot",oldRot, newRot, data[1]);
        
        
        if(!this.selectedObject) return;
        //FIXME: horrible hack!: this is done to prevent retriggering events when the undo 
        //redo operations change an object
        if(this.selectedObject._undoRedoFlag === true){
          this.selectedObject._undoRedoFlag = false;
          return;
        }
        
        
        
        if(! this._origRot){
          var offset = 3;
          var idx = data[1] . length-1 - offset;
          var arr = [ data[0][offset], data[0][offset+1], data[0][offset+2] ] ;
          arr[ idx ] = oldRot;
          var rot = new THREE.Vector3(arr).fromArray( arr );
          //console.log("gna",oldPos, newPos, pos);
          this._origRot = rot;
        }
        this.job("objectRotationChanged", function(){
          var offset = 3;
          var arr = [ data[0][offset], data[0][offset+1], data[0][offset+2] ] ;
          var rot = new THREE.Vector3().fromArray( arr );
          //console.log("oldPos, newPos",this._origPos, pos);
          var offset = rot.clone().sub( this._origRot );
          //console.log("offset",offset);
          if(offset.length() > 0 )
          {
            var operation = new Rotation( offset , this.selectedObject );
            var event = new CustomEvent('newOperation',{detail: {msg: operation}});
          
            this.dispatchEvent(event);
          }
          this._origRot = null;
          
        }, 100)
        
      },
      objectScaleChanged:function( oldScale, newScale, data ){
        console.log("oldScale, newScale",oldScale, newScale);
        
        if(!this.selectedObject) return;
        //FIXME: horrible hack!: this is done to prevent retriggering events when the undo 
        //redo operations change an object
        if(this.selectedObject._undoRedoFlag === true){
          this.selectedObject._undoRedoFlag = false;
          return;
        }
        if(! this._origScale){
          var offset = 6;
          var idx = data[1] . length-1 - offset;
          var arr = [ data[0][offset], data[0][offset+1], data[0][offset+2] ] ;
          arr[ idx ] = oldScale;
          var scale = new THREE.Vector3(arr).fromArray( arr );
          //console.log("gna",oldPos, newPos, pos);
          this._origScale = scale;
        }
        this.job("objectScaleChanged", function(){
          var arr = [ data[0][6], data[0][7], data[0][8] ] ;
          var scale = new THREE.Vector3().fromArray( arr );
          //console.log("oldPos, newPos",this._origPos, pos);
          var offset = scale.clone().sub( this._origScale );
          //console.log("offset",offset);
          if(offset.length() > 0 )
          {
            var operation = new Scaling( offset , this.selectedObject );
            var event = new CustomEvent('newOperation',{detail: {msg: operation}});
          
            this.dispatchEvent(event);
          }
          this._origScale = null;
          
        }, 100)
      },
      activeToolChanged:function( oldTool, newTool ){
        console.log("this.activeTool", this.activeTool, oldTool, newTool);
        this._prevTool = oldTool;
        
        var controlableTools = this._controlableTools;
        
        if(this.activeTool === "" || controlableTools.indexOf(this.activeTool) === -1){
          this.controls.detach(this.selectedObject );
          this.controls.enabled = false;
        }
        else{ 
          if(this.selectedObject && !(this.selectedObject instanceof AnnotationHelper) ){
            this.controls.enabled = true;
            this.controls.attach(this.selectedObject ); 
          }
        }
        
        if(controlableTools.indexOf(this.activeTool) > -1 ){ //&& this.selectedObject){
          //console.log("setting controls mode to " , this.activeTool);
          this.controls.setMode(this.activeTool);
        }
      },
      
      selectedObjectChanged:function( oldSelection, newSelection ){
         /*transformcontrols get
          ATTACHED when:
           - toolCategory is NOT annotations AND a tool IS active
           - transforms ARE ENABLED AND selection is NOT an annotation
          
          DETACHED when:
            - controls had something attached ...
          */
        if(! (oldSelection instanceof AnnotationHelper))
        {
          this.controls.detach( oldSelection );
        }
        
        var controlableTools = this._controlableTools;
        if(this.activeTool && this.activeTool !== "" && controlableTools.indexOf(this.activeTool) !== -1){
          if(this.selectedObject && !(this.selectedObject instanceof AnnotationHelper) ){
            this.controls.enabled = true;
            this.controls.attach(this.selectedObject ); 
          }
        }
        
        /*if(this.controls.enabled && !(newSelection instanceof AnnotationHelper)){
          this.controls.attach( newSelection );
        }*/
      },
      //this method will get added to the viewer
      //api
      toRotateMode:function(){
        this.activeTool = this.activeTool === "rotate" ? null: "rotate";
      }, 
      toTranslateMode:function(){
        this.activeTool = this.activeTool === "translate" ? null: "translate";
      }, 
      toScaleMode:function(){
        this.activeTool = this.activeTool === "scale" ? null: "scale";
      }, 
      
      
    });
    </script>
</polymer>

